# 🛠️ Pizzafly 遊戲機制詳解

本文檔詳細說明 Pizzafly 的各項遊戲機制，為開發團隊提供技術實現指南。

## 目錄

1. [核心系統架構](#核心系統架構)
2. [經營系統](#經營系統)
3. [物理互動系統](#物理互動系統)
4. [配料系統](#配料系統)
5. [角色與AI系統](#角色與ai系統)
6. [事件系統](#事件系統)
7. [多人網路系統](#多人網路系統)
8. [UI/UX系統](#uiux系統)
9. [進度與存檔系統](#進度與存檔系統)
10. [性能優化建議](#性能優化建議)
11. [成就系統](#成就系統)

---

這是一份根據您的需求，為《Pizzafly》遊戲設計的更完整技術文件，涵蓋了您提出的所有章節。

-----

### \# Pizzafly - 技術設計文件

## 1\. 核心系統架構

為了確保遊戲的模組化與可擴展性，我們將遊戲邏輯劃分為多個獨立的單一職責模組。每個模組負責特定的功能，並通過公共介面相互溝通。

### 主要模組

  - **GameManager**: 遊戲的總控制中心，管理遊戲狀態（如遊戲開始、結束、暫停）、場景加載、玩家資料儲存與讀取。
  - **RestaurantManager**: 負責所有餐廳經營相關的邏輯，包括財務管理、員工管理、設備狀態與升級。
  - **PhysicsManager**: 專門處理遊戲中瘋狂的物理互動，優化物理計算，並管理特殊物理效果（如披薩麵團的彈性）。
  - **OrderSystem**: 管理顧客的訂單生成、分配、追蹤與完成。
  - **EventSystem**: 事件觸發與處理，並與新聞系統連動。
  - **NetworkManager**: 多人同步，包含玩家位置、物件狀態與訂單同步。
  - **UIManager**: 介面管理，統一管理所有遊戲介面（UI）的顯示、隱藏與互動。
  - **AISystem**: 管理所有 NPC 顧客與員工的行為邏輯。
  - **AchievementSystem**: 管理成就的解鎖與追蹤。

-----

## 2\. 經營系統

這個模組將處理所有與餐廳經營相關的複雜邏輯，確保玩家的每個決策都能對財務與聲譽產生真實影響。

### 財務管理

`FinancialSystem.cs` 是一個獨立的組件，附屬於 `RestaurantManager`。它負責追蹤所有收入與支出。

```csharp
public class FinancialSystem 
{
    public float CurrentMoney { get; private set; }
    public float DailyRevenue { get; private set; }
    public float DailyCosts { get; private set; }
    
    // 成本計算
    public void CalculateCosts()
    {
        // 食材成本
        // 員工薪資
        // 設備維護
        // 租金
    }
}
```

### 庫存管理

`InventoryManager.cs` 負責管理所有食材與非食品庫存。

**Unity 實作說明**:

  - 創建一個 `InventoryManager` 腳本，使用字典（`Dictionary<string, InventoryItem>`）來儲存各種物品及其數量。
  - `InventoryItem` 類別包含物品名稱、數量、進貨成本、以及過期時間等屬性。
  - 定期檢查過期物品，並從庫存中移除，同時計入成本。

-----

## 3\. 物理互動系統

這個系統將是《Pizzafly》獨特樂趣的來源。它需要精細的物理參數調整與事件監聽。

### 物理物件管理

`PhysicsManager.cs` 將管理所有可互動的物理物件，並處理特定事件。

**Unity 實作說明**:

  - 所有可互動物件（如披薩、食材、餐具）都應有 `Rigidbody` 和 `Collider`。
  - 創建一個 `InteractableObject.cs` 腳本，內含 `OnGrab()`, `OnDrop()`, `OnThrow()` 等方法，並透過事件或委託（Delegate）通知 `PhysicsManager`。
  - 利用 Unity 的 `Physics` 函式庫，如 `Physics.Raycast` 進行物件拾取，並使用 `Rigidbody.AddForce` 實現投擲效果。

-----

## 4\. 配料系統

配料系統是遊戲創意的核心。它必須能夠處理任何物件作為配料。

**Unity 實作說明**:

  - 創建一個 `ToppingData` ScriptableObject，用於儲存每種配料的屬性，如名稱、成本、外觀模型、以及是否為「非食品」的標記。
  - 披薩模型將由一個核心圓盤和多個可獨立附著的配料模型組成。
  - 使用 `Instantiate` 方法動態生成配料物件，並將其父級設為披薩模型，以確保配料跟隨披薩移動。
  - `Pizza.cs` 腳本將維護一個配料列表，記錄每個披薩上放置了哪些配料。

-----

## 5\. 角色與 AI 系統

這個系統將處理所有 NPC 的行為，從點餐到對玩家行為的反應。

### 顧客 AI

**Unity 實作說明**:

  - 創建 `CustomerAI.cs` 腳本，使用**狀態機**來管理顧客的行為，例如：`WalkingToCounter`, `WaitingForOrder`, `Eating`, `Leaving`。
  - 顧客 AI 將會與 `OrderSystem` 互動，當進入 `WaitingForOrder` 狀態時，向 `OrderSystem` 發送請求。
  - 顧客的評價將基於多個參數：製作時間、披薩品質（配料種類、是否過期）、以及玩家的服務態度。

### 員工 AI

**Unity 實作說明**:

  - 創建 `EmployeeAI.cs` 腳本，類似於顧客 AI，但其狀態機將基於其專長。例如，「收納大師」會優先執行 `OrganizingInventory` 狀態，而「金牌店員」則會優先執行 `CleaningTables`。

-----

## 6\. 事件系統

這個系統將為遊戲增添不可預測性與挑戰性。

**Unity 實作說明**:

  - 創建一個 `EventManager` 腳本，使用一個計時器或隨機觸發器來觸發事件。
  - 每個事件可以是一個 ScriptableObject，其中包含事件名稱、效果描述，以及觸發後的邏輯腳本。
  - `EventManager` 在觸發事件時，會呼叫相應的邏輯，例如「熱浪來襲」事件會暫時提高飲料的銷售率，並可能觸發 `InventoryManager` 的特定函數。

-----

## 7\. 多人網路系統

網路同步是實現多人合作與競爭模式的關鍵。

**Unity 實作說明**:

  - 選擇一個網路解決方案（如 Photon PUN 2 或 Mirror）。
  - 使用\*\*網路變數（Networked Variables）\*\*來同步簡單的數據，如玩家位置和旋轉。
  - 對於更複雜的數據（如披薩的配料清單），使用\*\*遠程程序呼叫（RPC）\*\*來確保所有客戶端同步。例如，當一個玩家在披薩上添加一個配料時，會發送一個 RPC 給所有玩家，以同步這個動作。
  - 在 `NetworkManager` 腳本中，管理房間的創建、加入與退出，並處理玩家斷線重連的邏輯。

-----

## 8\. UI/UX 系統

好的 UI/UX 設計可以讓玩家更輕鬆地管理混亂的店鋪。

**Unity 實作說明**:

  - 使用 Unity UI 系統（Canvas, Rect Transform）來建立所有介面。
  - **手機介面**：使用一個 3D 模型作為手機，並在其螢幕上顯示 UI Canvas。這樣可以讓玩家在遊戲世界中直接操作手機。
  - **訂單顯示**：使用一個動態列表來顯示所有待處理的訂單，並用顏色或圖標標示緊急程度。
  - **日結算報表**：使用 UI 腳本動態生成圖表，顯示每日的營收、成本與利潤，並根據數據顯示有趣的文字註解。

-----

## 9\. 進度與存檔系統

存檔系統必須能夠保存玩家的進度，讓他們可以隨時繼續遊戲。

**Unity 實作說明**:

  - 使用 **JSON 或二進位格式**來儲存遊戲資料。
  - 存檔資料應包含：
      - 玩家的當前金錢、等級與技能點。
      - 餐廳的當前狀態（設備、裝潢）。
      - 倉庫庫存與過期時間。
      - 雇用的員工列表。
      - 已解鎖的成就。
  - 遊戲應在每個營業日結束時自動存檔，同時也提供手動存檔功能。

-----

## 10\. 性能優化建議

由於遊戲包含大量的物理互動，性能優化是開發的重點。

**Unity 實作說明**:

  - **物件池（Object Pooling）**：對於頻繁生成的物件（如食材、披薩），使用物件池技術來減少 `Instantiate` 和 `Destroy` 的開銷。
  - **物理效能管理**：
      - 調整物理更新頻率（`Time.fixedDeltaTime`），以平衡物理精確度與性能。
      - 適當使用 `Rigidbody.IsKinematic` 來凍結不需要物理模擬的物件。
  - **渲染優化**：
      - 使用 **GPU Instancing** 來批量渲染相同的配料模型。
      - 啟用**遮擋剔除（Occlusion Culling）**，以避免渲染被其他物件擋住的部分。

-----

## 11\. 成就系統

成就系統將激勵玩家探索遊戲的深度與隱藏樂趣。

**Unity 實作說明**:

  - 創建一個 `AchievementManager` 腳本，負責追蹤玩家的遊戲進度。
  - 使用一個 ScriptableObject 或 JSON 文件來定義所有成就，包括普通成就與隱藏成就，以及它們的解鎖條件。
  - **事件監聽**：`AchievementManager` 將訂閱遊戲中的各類事件，例如：
      - `OnPizzaMade(pizza)`: 檢查是否滿足「製作第一個披薩」或「黑暗料理」的條件。
      - `OnReviewReceived(review)`: 檢查是否獲得五星或一星評價。
      - `OnItemThrown(item)`: 檢查是否滿足「飛吧！披薩」的條件。
  - 當滿足解鎖條件時，將成就狀態標記為「已解鎖」，並在 UI 上顯示通知。
---

**這份文檔將隨開發進度持續更新，請定期檢查最新版本！** 🛠️✨